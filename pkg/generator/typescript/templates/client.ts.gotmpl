{{- $schemes := .IR.SecuritySchemes -}}

export type ClientOption = {
  baseURL?: string;
  headers?: Record<string, string>;
  timeoutMs?: number;
  retry?: { retries: number; backoffMs: number; retryOn?: number[] };
  onRequest?: (ctx: { url: string; init: RequestInit & { path: string; method: string; query?: Record<string, any> }; attempt: number }) => void | Promise<void>;
  onResponse?: (ctx: { url: string; init: RequestInit & { path: string; method: string; query?: Record<string, any> }; attempt: number; response: Response }) => void | Promise<void>;
  onError?: (err: unknown, ctx: { url: string; init: RequestInit & { path: string; method: string; query?: Record<string, any> }; attempt: number }) => void | Promise<void>;
  // Environment & Auth
  env?: 'sandbox' | 'production';
  envBaseURLs?: { sandbox: string; production: string };
  accessToken?: string | (() => string | Promise<string>);
  headerName?: string;
  {{- range $s := $schemes }}
  {{- if eq $s.Type "http" }}
    {{- if eq $s.Scheme "bearer" }}
  {{ camel $s.Key }}?: string;
    {{- else if eq $s.Scheme "basic" }}
  {{ camel $s.Key }}?: { username: string; password: string };
    {{- end }}
  {{- else if eq $s.Type "apiKey" }}
  {{ camel $s.Key }}?: string;
  {{- end }}
  {{- end }}
  fetch?: typeof fetch;
};

export class ApiError<T = unknown> extends Error {
  constructor(
    message: string,
    readonly status: number,
    readonly data?: T,
    readonly headers?: Headers,
  ) {
    super(message);
    this.name = "ApiError";
  }
}

export class CoreClient {
  constructor(private cfg: ClientOption = {}) {
    // Set default base URL if not provided
    if (!this.cfg.baseURL) {
      if (this.cfg.env && this.cfg.envBaseURLs) {
        this.cfg.baseURL = this.cfg.env === 'production' ? this.cfg.envBaseURLs.production : this.cfg.envBaseURLs.sandbox;
      } else {
        this.cfg.baseURL = "{{ .Client.DefaultBaseURL }}";
      }
    }
  }
  setAccessToken(token: string | (() => string | Promise<string>)) {
    this.cfg.accessToken = token;
  }
  async request(
    init: RequestInit & {
      path: string;
      method: string;
      query?: Record<string, any>;
    }
  ) {
    let normalizedPath = init.path || "";
    if (normalizedPath.length > 1 && normalizedPath.endsWith('/')) {
      normalizedPath = normalizedPath.slice(0, -1);
    }
    const url = new URL((this.cfg.baseURL || "") + normalizedPath);
    if (init.query) {
      Object.entries(init.query).forEach(([k, v]) => {
        if (v === undefined || v === null) return;
        if (Array.isArray(v))
          v.forEach((vv) => url.searchParams.append(k, String(vv)));
        else url.searchParams.set(k, String(v));
      });
    }
    {{- range $s := $schemes }}
    {{- if and (eq $s.Type "apiKey") (eq $s.In "query") }}
    if (this.cfg.{{ camel $s.Key }}) {
      url.searchParams.set("{{ $s.Name }}", String(this.cfg.{{ camel $s.Key }}));
    }
    {{- end }}
    {{- end }}
    const headers = new Headers({
      ...(this.cfg.headers || {}),
      ...(init.headers as any),
    });
    // Generic access token support (optional)
    if (this.cfg.accessToken) {
      const token = typeof this.cfg.accessToken === 'function' ? await this.cfg.accessToken() : this.cfg.accessToken;
      const name = this.cfg.headerName || 'Authorization';
      if (name.toLowerCase() === 'authorization') headers.set(name, `Bearer ${String(token)}`);
      else headers.set(name, String(token));
    }
    {{- range $s := $schemes }}
    {{- if eq $s.Type "http" }}
      {{- if eq $s.Scheme "bearer" }}
    if (this.cfg.{{ camel $s.Key }})
      headers.set("Authorization", `Bearer ${this.cfg.{{ camel $s.Key }}}`);
      {{- else if eq $s.Scheme "basic" }}
    if (this.cfg.{{ camel $s.Key }}) {
      const u = this.cfg.{{ camel $s.Key }}.username;
      const p = this.cfg.{{ camel $s.Key }}.password;
      const encoded = typeof btoa !== 'undefined' ? btoa(`${u}:${p}`) : (typeof Buffer !== 'undefined' ? Buffer.from(`${u}:${p}`).toString('base64') : '' );
      if (encoded) headers.set("Authorization", `Basic ${encoded}`);
    }
      {{- end }}
    {{- else if eq $s.Type "apiKey" }}
      {{- if eq $s.In "header" }}
    if (this.cfg?.{{ camel $s.Key }})
      headers.set("{{ $s.Name }}", String(this.cfg?.{{ camel $s.Key }}));
      {{- else if eq $s.In "cookie" }}
    if (this.cfg?.{{ camel $s.Key }})
      headers.set("Cookie", `${"{{ $s.Name }}"}=${String(this.cfg?.{{ camel $s.Key }})}`);
      {{- end }}
    {{- end }}
    {{- end }}
    const doFetch = async (attempt: number) => {
      if (this.cfg.onRequest) await this.cfg.onRequest({ url: url.toString(), init, attempt });
      let controller: AbortController | undefined;
      let timeoutId: any;
      const fetchInit: RequestInit = { ...init, headers };
      if (this.cfg.timeoutMs && typeof AbortController !== 'undefined') {
        controller = new AbortController();
        fetchInit.signal = controller.signal;
        timeoutId = setTimeout(() => controller?.abort(), this.cfg.timeoutMs);
      }
      try {
        const res = await (this.cfg.fetch || fetch)(url.toString(), fetchInit);
        if (this.cfg.onResponse) await this.cfg.onResponse({ url: url.toString(), init, attempt, response: res });
        const ct = res.headers.get("content-type") || "";
        let parsed: any;
        if (ct.includes("application/json")) {
          parsed = await res.json();
        } else if (ct.startsWith("text/")) {
          parsed = await res.text();
        } else {
          // binary or unknown -> ArrayBuffer
          parsed = await res.arrayBuffer();
        }
        if (!res.ok) {
          throw new ApiError(`HTTP ${res.status}`, res.status, parsed, res.headers);
        }
        return parsed as any;
      } catch (err) {
        if (this.cfg.onError) await this.cfg.onError(err, { url: url.toString(), init, attempt });
        throw err;
      } finally {
        if (timeoutId) clearTimeout(timeoutId);
      }
    };

    const retries = this.cfg.retry?.retries ?? 0;
    const baseBackoff = this.cfg.retry?.backoffMs ?? 300;
    const retryOn = this.cfg.retry?.retryOn ?? [429, 500, 502, 503, 504];

    let lastError: unknown;
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        return await doFetch(attempt);
      } catch (err: any) {
        // Retry on network errors or configured status errors
        const status = err?.status as number | undefined;
        const shouldRetry = status ? retryOn.includes(status) : true;
        if (attempt < retries && shouldRetry) {
          const delay = baseBackoff * Math.pow(2, attempt);
          await new Promise((r) => setTimeout(r, delay));
          lastError = err;
          continue;
        }
        if (err instanceof ApiError) throw err;
        throw new ApiError((err as Error)?.message || 'Network error', status ?? 0);
      }
    }
    throw lastError as any;
  }
}
